#!/opt/perl-5.8.8/bin/perl

use strict;
use EutilsJson;
use Data::Dumper;

# These are just the databases which are still in IDX, not CIDX.
# Their DTDs were autogenerated by an older tool, that does not add
# the JSON annotation automatically.  So, those annotations were added
# manually by CFM; see EU-2002.

my @idxDbs = qw(
    assembly
    bioproject
    biosample
    biosystems
    blastdbinfo
    cdd
    dbvar
    entrezfilters
    epigenomics
    gap
    gapplus
    gcassembly
    gencoll
    genome
    genomeprj
    homologene
    journals
    ncbisearch
    omia
    omim
    pcassay
    probe
    pubmedhealth
    snp
    sra
    structure
    toolkit
    toolkitall
    unigene
    unists
);
my %testResults;
foreach my $db (@idxDbs) {
    $testResults{$db} = {
        'samples-exist' => 0,  # if there are samples in samples.xml
        'dtd-found' => 0,      # if we found the DTD on the filesystem
    };
}

# $IDXEXT_DIR  points to the base directory of the subtree under which are all
# of the DTDs.  This is the working copy of the subversion directory
# https://svn.ncbi.nlm.nih.gov/repos/toolkit/trunk/internal/c++/src/internal/idxext
# Any given DTD is at $IDXEXT_DIR/<db>/support/esummary_<db>.dtd
my $IDXEXT_DIR = "/home/maloneyc/svn/toolkit/trunk/internal/c++/src/internal/idxext";

my $samples = EutilsJson::readSamples();
print Dumper($samples);


foreach my $samplegroup (@$samples) {
    my $dtd = $samplegroup->{dtd};

    # If the DTD is not of the form esummary_<db>.dtd, where <db> is one
    # of the IDX databases above, then skip it.
    next if $dtd !~ /esummary_([a-z]+)\.dtd/;
    my $db = $1;
    print "Checking $dtd => $db\n";

    if (!exists $testResults{$db}) {
        print "    not an idx database, skipping ...\n";
        next;
    }
    else {
        $testResults{$db}{'samples-exist'} = 1;
    }
    print "    Testing $dtd\n";

    # See if the DTD exists on the filesystem
    my $dtdpath = "$IDXEXT_DIR/$db/support/esummary_$db.dtd";
    if (-f $dtdpath) {
        $testResults{$db}{'dtd-found'} = 1;
    }
    else {
        print "        FAILED:  can't find $dtdpath\n";
        next;
    }

    # For each sample corresponding to this DTD:

    my $groupsamples = $samplegroup->{samples};
    foreach my $s (@$groupsamples) {
        my $status;

        # Fetch the XML for this eutilities sample URL
        my $eutilsUrl = $EutilsJson::eutilsBaseUrl . $s->{"eutils-url"};
        my $samplexml = $s->{name} . ".xml";
        $eutilsUrl =~ s/\&/\\\&/g;
        print "        Fetching $eutilsUrl => $samplexml\n";
        $status = system "curl --silent --output $samplexml $eutilsUrl";
        if ($status != 0) {
            print "            ... FAILED!\n";
            next;
        }

        # Validate this sample against the new DTD.  There's still a problem
        # with this validation, because it still tries to read the instance
        # document's specified DTD over the network, even though it's not using
        # that for validation.  So this will fail if that DTD doesn't exist
        # (pubmedhealth).
        my $xmllint_cmd = "xmllint --noout --dtdvalid $dtdpath $samplexml";
        print "        Validating:  '$xmllint_cmd'\n";
        $status = system $xmllint_cmd;
        if ($status != 0) {
            print STDERR "            $samplexml FAILED to validate!\n";
            next;
        }
    }





    # Done up to here
    next;

    # Next steps:  generate the -2json.xml, generate JSON, and validate it.

    my $basename = $dtd;
    $basename =~ s/\.dtd$//;
    my $tojsonxsl = $basename . '-2json.xsl';

    my $status = system "dtd2xml2json $dtd $tojsonxsl";
    if ($status != 0) {
        print "Failed to generate $tojsonxsl; skipping.\n";
        next;
    }

    my $groupsamples = $samplegroup->{samples};
    foreach my $s (@$groupsamples) {
        print "  testing $s->{name}\n";

        # Fetch the XML for this eutilities sample URL
        my $eutilsUrl = $EutilsJson::eutilsBaseUrl . $s->{"eutils-url"};
        my $samplexml = $s->{name} . ".xml";
        $eutilsUrl =~ s/\&/\\\&/g;
        print "    fetching $eutilsUrl\n";
        $status = system "curl --silent --output $samplexml $eutilsUrl";
        if ($status != 0) {
            print "      ... failed!\n";
            next;
        }

        # Validate the XML
        $status = system "xmllint --noout --valid --nonet $samplexml";
        if ($status != 0) {
            print "    Failed to validate!\n";
            die;
        }
    }
}

